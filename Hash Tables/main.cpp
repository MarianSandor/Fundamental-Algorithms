#include<stdlib.h>
#include<stdio.h>
#include<string.h>
#include "Profiler.h"

/*
	Hash Table
   ------------
		In this case the hash table is build using open addressing and the choice of implementation is qudratic probing.

	  Open Addressing 
			Open Addressing implies that all the elements in the table have theri own place at a specific address. Different
		  from close addressing method, now the size of the array plays an important role since the data can only be stored
		  inside the table. This technique is very usefull when the number of elements cand be approximated in advanced.
		  The advdantage is that it gives good performence when it comes to insertion and searching operations. It is good 
		  to keep in mind that deletion of an element may cause problems if not performed in an appropiate way. The deleted 
		  elements must be signed as "deleted" and when searching those elements are skipped.

	 Quadratic Probing
			It is one of the three ways of probing a slot in the hash table. In terms of perfomance it is somewhere between
	      linear probing and double hashing dealing well with the clustering problem.

			The form of the hash function is --> h(x) = h'(x) + c1 * i + c2 * i^2;
				-choosing c1 and c2 to be 1 the function performs good in practice.

	Performence
		When talking about the performence of this implementation we first must fix a few things
			Suppose we have n elements and the size of the table is m.
				- Since no external space is used n must be <= m.
				- The load factor alpha = n/m must be <= 1.
				- We assume that uniform hashing is performed and that each key in the table is equally 
			  likely to be searched for.

			In case of an unsuccessful search the number of probes done ==> 1/(1 - alpha)
			In case of a successful search the number of probes done ==> 1/alpha * ln(1 / (1 - alpha))

			In general the number of probes performed by any operation ==> 1/(1 - alpha)

		This can be proven mathematically or by checking with the table generated by the program.
*/

int EFFORT, MAX_EFFORT;
double AVG_EFFORT_F, AVG_EFFORT_NF, AVG_MAX_EFFORT_F, AVG_MAX_EFFORT_NF;

typedef struct {
	int id;
	char name[30];
} Entry;

Entry* createEntry(int id, char name[30]) {
	Entry* entry = (Entry*)malloc(sizeof(Entry));

	if (entry)
	{
		entry->id = id;
		strcpy_s(entry->name, name);

		return entry;
	}

	return NULL;
}

Entry** createHashTable(int size) {
	Entry** table = (Entry**)malloc(size * sizeof(Entry*));

	if (table)
	{
		for (int i = 0; i < size; i++)
		{
			*(table + i) = NULL;
		}

		return table;
	}

	return NULL;
}

void freeHashTable(Entry** table, int size) {

	for (int i = 0; i < size; i++)
	{
		free(table[i]);
	}

	free(table);
}

void printRow(int ratio) {
	printf("-----------------------------------------------------------------------\n");
	printf("%.2f | %.2f      | %.2f         | %.2f          | %.2f\n", (double)ratio / 100, AVG_EFFORT_F, AVG_MAX_EFFORT_F, AVG_EFFORT_NF, AVG_MAX_EFFORT_NF);
}

int getSizeByRatio(int ratio, int size) {
	return size * ratio / 100;
}

int hash1(int size, int id) {
	return id % size;
}

int hash2(int c1, int c2, int i, int id, int size) {
	return (hash1(size, id) + c1 * i + c2 * i * i) % size;
}

int insertHashTable(Entry** hashTable, Entry* entry, int size) {
	int i = 0;
	int j;

	do {
		j = hash2(1, 1, i, entry->id, size);

		if (hashTable[j] == NULL) {
			hashTable[j] = entry;
			return j;
		}

		i++;
	} while (i < size);

	return -1;
}

int searchHashTable(Entry** hashTable, int id, int size) {
	int i = 0;
	int j;

	do {
		j = hash2(1, 1, i, id, size);
		if (hashTable[j] == NULL)
		{
			return -1;
		}

		if (hashTable[j]->id == id) {
			return j;
		}

		i++;
		EFFORT++;
	} while (i < size);

	return -1;
}

void createSampleInput(int size, int sizeProb, int* sample, int* probT, int* probF) {
	int finalSize = size + sizeProb;
	int j;

	int* a = (int*)malloc(finalSize * sizeof(int));
	FillRandomArray(a, finalSize, 10, 50000, true, 0);

	for (int i = 0; i < size; i++)
	{
		sample[i] = a[i];
	}
	
	int space = size / sizeProb;
	int index = (size - space * sizeProb) / 2;
	j = 0;

	while (j < sizeProb)
	{
		probT[j] = a[index];
		j++;
		index += space;
	}
	/*

	int* b = (int*)malloc(sizeProb * sizeof(int));
	FillRandomArray(b, sizeProb, 0, size - 1, true, 0);
	for (int i = 0; i < sizeProb; i++)
	{
		probT[i] = a[b[i]];
	}
	*/
	j = 0;
	for (int i = size; i < finalSize; i++)
	{
		probF[j] = a[i];
		j++;
	}
}

void fillHashTable(Entry** hashTable, int sizeTable, int* sample, int sizeSample) {
	char name[30] = "";

	for (int i = 0; i < sizeSample; i++)
	{
		Entry* entry = createEntry(sample[i], name);
		insertHashTable(hashTable, entry, sizeTable);
	}
}

void printHashTable(Entry** hashTable, int sizeTable) {
	for (int i = 0; i < sizeTable; i++)
	{
		if (hashTable[i] != NULL) {
			printf("Data stored at index %d: id = %d  name = %s\n", i, hashTable[i]->id, hashTable[i]->name);
		}
		else {
			printf("Data stored at index %d: \n", i);
		}
	}
}

void demo() {
	printf("\n \t\t\t DEMO START\n");

	char names[14][30] = { "Marian", "Ana", "Marcel", "Flavius", "Marcela"
						   "Roxana", "Alex", "Ioana", "Andreea", "Rebeca" 
		                   "Daniela", "Marius", "Sergiu", "Sebastian" };
	int* keys = (int*)malloc(14 * sizeof(int));
	FillRandomArray(keys, 14, 10, 100, true, 0);

	Entry** hashTable = createHashTable(13);
	Entry* entry;
	
	int idTrue = keys[4];
	int idFalse = keys[13];

	for (int i = 0; i < 13; i++)
	{
		entry = createEntry(keys[i], names[i]);
		printf("Data to be inserted: id = %d  name = %s\n", entry->id, entry->name);

		insertHashTable(hashTable, entry, 13);

		printf("Table after insertion is done:\n");
		printHashTable(hashTable, 13);
		printf("-----------------------------------------------------------------------------------------\n");
	}

	printf("Searching for id: %d\n", idTrue);
	printf("Data with id: %d found at index: %d\n\n", idTrue, searchHashTable(hashTable, idTrue, 13));
	
	printf("Searching for id: %d\n", idFalse);
	printf("Data with id: %d found at index: %d\n", idFalse,searchHashTable(hashTable, idFalse, 13));

	freeHashTable(hashTable, 13);

	printf("\n \t\t\t DEMO END\n");
}

void searchFound(Entry** hashTable, int tableSize, int* probT, int size) {
	MAX_EFFORT = 0;
	EFFORT = 0;
	int currentEffort;

	for (int i = 0; i < size; i++)
	{	
		currentEffort = EFFORT;

		searchHashTable(hashTable, probT[i], tableSize);

		currentEffort = EFFORT - currentEffort;

		if (currentEffort > MAX_EFFORT)
		{
			MAX_EFFORT = currentEffort;
		}
	}
}

void searchNotFound(Entry** hashTable, int tableSize, int* probF, int size) {
	MAX_EFFORT = 0;
	EFFORT = 0;
	int currentEffort;

	for (int i = 0; i < size; i++)
	{
		currentEffort = EFFORT;

		searchHashTable(hashTable, probF[i], tableSize);

		currentEffort = EFFORT - currentEffort;

		if (currentEffort > MAX_EFFORT)
		{
			MAX_EFFORT = currentEffort;
		}
	}
}

void generateTable() {
	Entry** hashTable;
	int tableSize = 10007;
	int probSize = 1500;
	int ratio[] = { 80, 85, 90, 95, 99 };

	printf("\n \t\t\t EFORRT TABLE\n");
	printf("Alpha| Avg Found | Avg Max Found | Avg Not Found | Avg Max Not Found\n");

	for (int i = 0; i < 5; i++)
	{
		AVG_EFFORT_F = 0;
		AVG_EFFORT_NF = 0;
		AVG_MAX_EFFORT_F = 0;
		AVG_MAX_EFFORT_NF = 0;

		for (int j = 0; j < 5; j++)
		{
			int nbOfElements = getSizeByRatio(ratio[i], tableSize);

			int* sample = (int*)malloc(nbOfElements * sizeof(int));
			int* probT = (int*)malloc(probSize * sizeof(int));
			int* probF = (int*)malloc(probSize * sizeof(int));

			hashTable = createHashTable(tableSize);

			createSampleInput(nbOfElements, probSize, sample, probT, probF);
			fillHashTable(hashTable, 10007, sample, nbOfElements);

			searchFound(hashTable, tableSize, probT, probSize);
			AVG_EFFORT_F += (double) EFFORT / probSize;
			AVG_MAX_EFFORT_F += MAX_EFFORT;

			searchNotFound(hashTable, tableSize, probF, probSize);
			AVG_EFFORT_NF += (double) EFFORT / probSize;
			AVG_MAX_EFFORT_NF += MAX_EFFORT;

			free(sample);
			free(probF);
			free(probT);
			freeHashTable(hashTable, tableSize);
		}

		AVG_EFFORT_F = AVG_EFFORT_F / 5;
		AVG_EFFORT_NF = AVG_EFFORT_NF / 5;
		AVG_MAX_EFFORT_F = AVG_MAX_EFFORT_F / 5;
		AVG_MAX_EFFORT_NF = AVG_MAX_EFFORT_NF / 5;

		printRow(ratio[i]);
	}

	printf("\n");
}

void main() {
	
	demo();

	generateTable();
}
